# import()
이 저장소는 JavaScript에 "함수 형태"의 `import()` 모듈 로딩 구문을 추가하기 위한 제안을 포함하고 있습니다. 현재 이 제안은 [TC39 프로세스](https://tc39.es/process-document/) 4단계에 있습니다. 이전에는 [whatwg/loader#149](https://github.com/whatwg/loader/issues/149)에서 모듈 로딩 커뮤니티와 토의되었습니다.

진행 중인 [사양 초안](https://tc39.es/proposal-dynamic-import/)을 확인하고 [이슈 트래커](https://github.com/tc39/proposal-dynamic-import/issues)에서 토론에 참여할 수 있습니다.

## 제안 동기 및 사용 사례
기존에 모듈을 가져오기 위한 구문 형태는 정적 선언입니다. 모듈 지정자로 문자열 리터럴을 받고, 사전 런타임 "링킹" 프로세스를 통해 지역 스코프에 바인딩을 도입합니다. 이는 90% 이상의 경우 훌륭한 설계이며, 정적 분석, 번들링 도구 및 트리 쉐이킹과 같은 중요한 사용 사례를 지원합니다.

하지만 JavaScript 애플리케이션의 일부를 런타임에 동적으로 로드할 수 있는 기능도 필요합니다. 이는 런타임에서만 알 수 있는 요인(사용자의 언어와 같은 것들), 성능 상의 이유(사용할 가능성이 있는 코드만 로드), 또는 견고성(robustness) 이유(중요하지 않은 모듈의 로딩 실패에 대한 대응)로 인해 필요할 수 있습니다. 이러한 동적 코드 로딩은 특히 웹에서 오랜 역사를 가지고 있으며, Node.js에서도 마찬가지입니다(시작 비용을 지연시키기 위해). 기존의 `import` 구문은 이러한 사용 사례를 지원하지 않습니다.

동적 코드 로딩은 여러 모듈을 경쟁시켜서 가장 먼저 성공적으로 로드된 모듈을 선택하는 등 고급 시나리오를 가능하게 합니다.

## 제안된 해결책
이 제안은 `import(specifier)`구문 형식을 추가합니다. 이 구문은 함수와 많은 면에서 비슷하게 작동합니다(아래 참조). 이 구문은 요청한 모듈의 모듈 네임스페이스 객체에 대한 프로미스를 반환합니다. 그것은 모듈의 모든 종속성을 가져오고(fetching), 인스턴스화 하고, 평가한 후 생성됩니다.

여기서 `specifier`는 `import` 선언과 동일한 방식으로 해석됩니다(즉, 동일한 문자열이 두 곳 모두에서 동작합니다). 그러나 `specifier`는 문자열이지만 문자열 리터럴일 필요는 없으므로 `import(`./language-packs/${navigator.language}.js`)`와 같은 코드가 작동할 것입니다. 이는 일반적인 `import` 선언으로는 불가능한 작업입니다.


`import()`는 스크립트와 모듈 모두에서 작동하도록 제안되었습니다. 이를 통해 스크립트 코드는 모듈 세계에 쉽게 비동기적으로 진입할 수 있게 되어 모듈 코드를 동작할 수 있게 됩니다.

기존의 JavaScript 모듈 사양과 마찬가지로 모듈을 가져오는 정확한 메커니즘은 호스트 환경(예를 들어 웹 브라우저 또는 Node.js)에 맡겨져 있습니다. 이를 위해 기존의 HostResolveImportedModule을 재사용하고 약간 조정하여 새로운 호스트 환경 구현 추상 연산인 HostResolveImportedModule을 도입합니다.

(이 두 단계의 호스트 연산 구조는 HostResolveImportedModule이 항상 동기적으로 반환되고, 인수의 [[RequestedModules]] 필드를 사용하여 반환하는 의미를 보존하기 위해 존재합니다. HostResolveImportedModule은 이 방식으로 [[RequestedModules]] 필드를 동적으로 채우는 메커니즘으로 볼 수 있습니다. 이는 일부 호스트 환경에서 이미 모듈 트리거를 미리 가져오고 평가하여 모듈 평가 중에 발생하는 모든 HostResolveImportedModule 호출에서 요청한 모듈을 찾을 수 있도록 하는 것과 유사합니다.)

